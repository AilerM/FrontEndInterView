## 原型链
  - 创建对象有几种方法
  - 原型、构造函数、实例、原型链
  - instanceof原理
  - new运算符



### 创建对象有几种方法
```js
var o1 = {name: 'o1'}   
var o11 = new Object({name: 'o11)

var M = function () {
  this.name = 'o1'
}
var o1 = new M()

var P = {name: 'o3'}
var o3 = Object.create(P)  o3.__propto__ = P
```

### 原型、构造函数、实例、原型链
  实例：var o11实例
  构造函数：任何一个函数只要被new使用了，就可称之为构造函数
    函数都有prototype属性，生明函数的时候js自动添加属性 prototype就是【原型对象】
    原型对象，怎么区分，我是被哪个构造函数所引用的呢？ 
      constructor属性指向一个函数 构造器 M.prototype.constructor === M  M的原型对象(prototype)的属性(constructor)严格指向函数本身

  实例/构造函数/原型对象的关联
      构造函数-实例： **构造函数** 通过**new** 与**实例**关联
      构造函数-原型对象：构造函数的**原型对象(prototype)**，通过**属性(constructor)**与函数保持关联
      实例-原型对象：o3.__proto__ === M.prototype
    
  注意点：
    函数才有prototype 对象是没有的
    只有实例对象才有__proto__, 函数也有__proto__; M.__proto__ === Function.prototype


### instanceof原理
  只要在这个原型链上的构造函数函数，都会被instanceof看作是O3的构造函数 
    o3.__proto__ === M.prototype    //true
    M.prototype.__proto__ = Object.prototype  // true

    O3.__proto__.constructor === M   //true
    O3.__proto__.constructor === Object   //false


### new运算符
```js
var new2 = function(func) {
  var o = Object.crate(func.prototype)
  var k = func.call(o)
  if (typeof k === 'Object') {
    return k
  } else {
    return o
  }
}
o6 = new2(M)
```









```js
// 实例|构造函数|原型 关系

// 构造函数：
function Animate (name) {
  this.name = name
}
Animate.prototype.getName = function(){
  return this.name
}
// 实例：
var cat = new Animate 

// 实例 - 构造函数
cat.__proto__.constructor === Animate

// 构造函数 - 原型

Animate.prototype.constructor === Animate

// 原型 - 实例
Animate.prototype === cat.__proto__
```














